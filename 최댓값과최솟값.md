# 프로그래머스 <최대값과 최솟값>

문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 "(최소값) (최대값)"형태의 문자열을 반환하는 함수, solution을 완성하세요.
예를들어 s가 "1 2 3 4"라면 "1 4"를 리턴하고, "-1 -2 -3 -4"라면 "-4 -1"을 리턴하면 됩니다.

## [제한조건]
s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.

## 입출력 예
s	              return
"1 2 3 4"	      "1 4"
"-1 -2 -3 -4"	  "-4 -1"
"-1 -1"	        "-1 -1"

## [통과한 답안]
```
def solution(s):
    answer = ''
    arr=[]
    nlist=s.split(" ") # 주어진 문자열을 공백을 기준으로 리스트로 분리
    nlist = list(map(int, nlist)) # 현재 리스트의 각 요소들을 str인 상태이므로, 각각을 정수형으로 바꿔주었다.
    arr.append(min(nlist))
    arr.append(max(nlist))
    s1=" ".join([str(elem) for elem in arr]) # 각각을 int형으로 분리해놓았기에 문자열로 join 할 수 없어, 각각을 다시 str 형으로 바꿔주고 그다음에 문자열로 join 시켰다.
    return s1

```

## 시행착오
- test2번에 음수의 정수들이 오름차순으로 정렬했는데 반대로 정렬되었다!
- 이유를 알 수 없어 찾아봤지만, 그렇다 할 답을 얻지 못했다.
- 그런데 문득, 정수형이 아닌 문자열로 인식하고 있어 오름차순이 제대로 대소관계에 맞지 않게 정렬하는 듯해, 리스트의 원소들을 정수형으로 바꿔주었다. arr=(list(map(int,arr)) 사용
- 그런데, 이번엔 정수형이라 다시 문자열로 join 할 수 없어, 각 요소들을 str으로 바꿔주고 그 다음에 문자열로 join 하였다. s1= " ".join([str(elem) for elem in arr])
- 또한, min 과 max를 이용하지 않고, 오름차순으로 정렬하여, nlist[0] 과 nlist[-1]을 뽑아서 도출해도 가능하다.


## 다른 사람의 풀이
```
def solution(s):
    s = list(map(int,s.split())) # 내 풀이에서 20번라인 21번라인 한번에 작성 
    return str(min(s)) + " " + str(max(s)) # 22번~25번 줄 한번에...
```
